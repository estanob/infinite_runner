{"version":3,"file":"./lib/bundle.js","mappings":";;;;;;;;;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACRA,aAAa,mBAAO,CAAC,gCAAW;AAChC,eAAe,mBAAO,CAAC,oCAAa;AACpC,gBAAgB,mBAAO,CAAC,sCAAc;AACtC,qBAAqB,mBAAO,CAAC,kDAAoB;AACjD,cAAc,mBAAO,CAAC,kCAAY;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;AC1MA,kBAAkB,mBAAO,CAAC,+CAAqB;AAC/C,cAAc,mBAAO,CAAC,kCAAY;AAClC,aAAa,mBAAO,CAAC,gCAAW;AAChC,eAAe,mBAAO,CAAC,oCAAa;AACpC,mBAAmB,mBAAO,CAAC,4CAAiB;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,mBAAmB;AAC5C,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C,gCAAgC;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;ACpEA,aAAa,mBAAO,CAAC,gCAAW;AAChC,qBAAqB,mBAAO,CAAC,kDAAoB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC5CA,aAAa,mBAAO,CAAC,gCAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AChEA,qBAAqB,mBAAO,CAAC,kDAAoB;AACjD,aAAa,mBAAO,CAAC,gCAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC/BA,qBAAqB,mBAAO,CAAC,kDAAoB;AACjD,cAAc,mBAAO,CAAC,kCAAY;AAClC,aAAa,mBAAO,CAAC,gCAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,4BAA4B;AAC5B;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;;;AChCA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA,kBAAkB;AAClB,cAAc,4CAA4C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA,UAAU,KAAK;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gBAAgB,2BAA2B;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAA2E;AACvG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,yBAAyB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B,uBAAuB;;AAEvB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sBAAsB;AACvE;;AAEA;AACA,kDAAkD,iBAAiB,GAAG;AACtE;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK,IAA6B;;AAElC,CAAC;;;;;;UCxSD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;ACtBA;AACA,mBAAmB,mBAAO,CAAC,0CAAgB;AAC3C,eAAe,mBAAO,CAAC,gCAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,C","sources":["webpack://js_game/./lib/background.js","webpack://js_game/./lib/game.js","webpack://js_game/./lib/game_view.js","webpack://js_game/./lib/iceberg.js","webpack://js_game/./lib/moving_object.js","webpack://js_game/./lib/power.js","webpack://js_game/./lib/surfer.js","webpack://js_game/./lib/util.js","webpack://js_game/./src/keymaster.js","webpack://js_game/webpack/bootstrap","webpack://js_game/./lib/infinite_runner.js"],"sourcesContent":["let Background = function () {\n  this.backgroundImg = document.getElementById(\"background\");\n}\n\nBackground.prototype.drawBackground = function (ctx) {\n  ctx.drawImage(this.backgroundImg, 0, 0, 1200, 550)\n}\n\nmodule.exports = Background;","const Util = require('./util.js');\nconst Surfer = require('./surfer.js');\nconst Iceberg = require('./iceberg.js');\nconst MovingObject = require('./moving_object.js');\nconst Power = require('./power.js');\n\nclass Game {\n  constructor(ctx) {\n    this.surfer = {};\n    this.icebergs = [];\n    this.waves = [];\n    this.gameOver = false;\n    this.powerDistance = 500;\n    this.objects = this.allObjects();\n    this.gameCanvas = document.getElementById(\"game-canvas\") ? document.getElementById(\"game-canvas\") : {};\n    this.endScreen = document.getElementById(\"end-screen\") ? document.getElementById(\"end-screen\") : {};\n    this.numIcebergs = Game.NUM_ICEBERGS;\n    this.icebergsHit = 0;\n    this.ctx = ctx;\n  }\n  \n  surferStartPosition() {\n    const DIM_X = 150;\n    const DIM_Y = 250;\n    return [DIM_X, DIM_Y];\n  }\n  \n  randomPosition() {\n    const RAND_Y = Game.DIM_Y * Math.random() * Math.random();\n    return [Game.DIM_X, RAND_Y];\n  }\n  \n  randomWavePosition() {\n    const RAND_Y = Game.DIM_Y * Math.random() * Math.random();\n    return [0, RAND_Y];\n  }\n  \n  moveIcebergs(delta) {\n    this.allObjects().forEach(object => {\n      object.moveIceberg(delta);\n    });\n  }\n  \n  moveWaves(delta) {\n    this.waves.forEach(wave => {\n      setTimeout(() => {\n        wave.moveWave(delta);\n      }, 1500);\n    });\n  }\n  \n  isOutOfBounds(pos) {\n    return (\n      (pos[0] < 0) ||\n      (pos[1] < 0) ||\n      (pos[0] > Game.DIM_X) ||\n      (pos[1] > Game.DIM_Y - 100)\n    );\n  }\n  \n  remove(object) {\n    if (object instanceof Iceberg) {\n      this.icebergs.splice(this.icebergs.indexOf(object), 1);\n    };\n    if (object instanceof Power) {\n      this.waves.splice(this.waves.indexOf(object), 1);\n    };\n    if (object instanceof Surfer) {\n      this.surfer = {};\n    }\n  }\n  \n  removeIceberg() {\n    this.icebergs.forEach(iceberg => {\n      if (this.isOutOfBounds(iceberg.pos) || this.gameOver)\n        this.remove(iceberg);\n    });\n  }\n  \n  removeWave() {\n    const allObjects = this.allObjects();\n    allObjects.forEach(object => {\n      if (object instanceof Power) {\n        if (object.pos[0] > this.powerDistance) {\n          this.remove(object);\n        }\n      }\n    });\n  }\n  \n  removeSurfer() {\n    const allObjects = this.allObjects();\n    allObjects.forEach(object => {\n      if (object instanceof Surfer)\n        this.remove(object);\n    });\n  }\n  \n  addSurfer() {\n    const surfer = new Surfer({\n      pos: this.surferStartPosition(),\n      game: this,\n    });\n    this.surfer = surfer;\n    return this.surfer;\n  }\n  \n  addIcebergs() {\n    let icebergs = [];\n    for (let i = 0; i < Game.NUM_ICEBERGS; i++) {\n      setTimeout(() => {\n        icebergs.push(\n          new Iceberg({\n            game: this,\n            pos: this.randomPosition(),\n          })\n        );\n      }, i * 1000);\n    };\n    this.icebergs = icebergs\n    return this.icebergs;\n  }\n  \n  gameDraw(ctx) {\n    this.allObjects().forEach(object => {\n      if (object instanceof Power) {\n        object.drawWave(ctx)\n      } else if (object instanceof Surfer) {\n        object.drawSurfer(ctx)\n      } else if (object instanceof Iceberg) {\n        object.drawIceberg(ctx)\n      }\n    });\n  }\n  \n  allObjects() {\n    return [].concat(this.surfer, this.icebergs, this.waves);\n  }\n  \n  step(delta) {\n    this.moveWaves(delta);\n    this.moveIcebergs(delta);\n    this.surfer.moveSurfer(delta, this.surfer.vel, this.surfer.pos);\n    this.checkCrash();\n    this.removeWave();\n    this.powerUp();\n    this.endGame();\n  }\n  \n  checkCrash() {\n    const allObjects = this.allObjects();\n\n    for (let i = 0; i < allObjects.length; i++) {\n      for (let j = 0; j < allObjects.length; j++) {\n        const obj1 = allObjects[i];\n        const obj2 = allObjects[j];\n        if (obj1.crashedWith(obj2) && obj1 instanceof Iceberg && obj2 instanceof Surfer) {\n          alert(\"Game over.\");\n          this.gameOver = true;\n        }\n      }\n    }\n\n    for (let i = 0; i < allObjects.length; i++) {\n      for (let j = 0; j < allObjects.length; j++) {\n        let obj1 = allObjects[i];\n        let obj2 = allObjects[j];\n        if (obj1 instanceof Power && obj2 instanceof Iceberg) {\n          if (obj1.crashedWith(obj2)) {\n            obj1.remove();\n            obj2.remove();\n            this.icebergsHit++;\n          }\n        }\n      }\n    }\n  }\n\n  powerUp() {\n    if ((this.icebergsHit >= (Game.NUM_ICEBERGS * .5)) && (this.icebergsHit < (Game.NUM_ICEBERGS * .75))) {\n      this.powerDistance = 600;\n    } else if ((this.icebergsHit >= (Game.NUM_ICEBERGS * .75)) && (this.icebergsHit < (Game.NUM_ICEBERGS * .8))) {\n      this.powerDistance = 650;\n    } else if (this.icebergsHit >= (Game.NUM_ICEBERGS * .8)) {\n      this.powerDistance = 700;\n    }\n  }\n\n  endGame() {\n    if (this.gameOver) {\n      this.objects = [];\n      this.icebergsHit = 0;\n      this.gameCanvas.classList.add(\"hidden\");\n      this.endScreen.classList.remove(\"hidden\");\n    }\n  }\n}\n\nGame.DIM_X = 1200;\nGame.DIM_Y = 550;\nGame.NUM_ICEBERGS = Math.ceil((100 * Math.random()) * (100 * Math.random()));\n\nmodule.exports = Game;","const KeyMaster = require('../src/keymaster.js');\nconst Power = require('./power.js');\nconst Game = require('./game.js');\nconst Surfer = require('./surfer.js');\nconst Background = require('./background.js');\n\nconst GameView = function (game, ctx) {\n  this.ctx = ctx;\n  this.game = game;\n  this.surfer = this.game.addSurfer();\n  this.icebergs = this.game.addIcebergs();\n};\n\nconst gameContainer = document.getElementById(\"game-container\");\nconst canvas = document.getElementById(\"game-canvas\");\n\nGameView.MOVES = {\n  \"up\": [0, -1],\n  \"down\": [0, 1],\n  \"left\": [-1, 0],\n  \"right\": [1, 0],\n};\n\nGameView.prototype.bindKeyHandlers = function () {\n  const surfer = this.surfer;\n\n  Object.keys(GameView.MOVES).forEach(k => {\n    let move = GameView.MOVES[k];\n    key(k, function () { surfer.surf(move) }) \n  })\n\n  key(\"space\", function () { \n    surfer.waterBend()\n   });\n};\n\nGameView.prototype.start = function () {\n  this.backGround = new Background(this.ctx)\n  this.game.score = 0;\n  this.game.gameOver = false;\n  this.bindKeyHandlers();\n  this.lastTime = 0;\n  requestAnimationFrame(this.animate.bind(this));\n};\n\nGameView.prototype.animate = function (time) {\n  const delta = time - this.lastTime;\n  this.backGround.drawBackground(this.ctx); // draw background first\n  this.game.gameDraw(this.ctx); // then draw all items on top of background\n  this.lastTime = time;\n  this.displayIcebergInfo();\n  this.game.step(delta);\n  requestAnimationFrame(this.animate.bind(this));\n};\n\nGameView.prototype.displayIcebergInfo = function () {\n  this.ctx.fillStyle =\"#045080\"\n  this.ctx.font = \"15px BlinkMacSystemFont,Roboto,Helvetica Neue,Arial,sans-serif\"\n  this.ctx.fillText(\"Number of Icebergs: \" + this.game.numIcebergs, 10, 20)\n  this.ctx.fillText(\"Icebergs Hit: \" + this.game.icebergsHit, 10, 40)\n}\n\nGameView.prototype.restart = function () {\n  gameContainer.classList.remove(\"hidden\")\n  canvas.classList.remove(\"hidden\")\n  this.start();\n}\n\nmodule.exports = GameView;","const Util = require('./util.js');\nconst MovingObject = require('./moving_object.js');\n\nconst DEFAULTS = {\n  COLOR: \"#888c89\",\n  WIDTH: 80,\n  HEIGHT: 90,\n  RADIUS: 15,\n  SPEED: 1,\n};\n\nconst icebergImg = new Image ();\nicebergImg.src = 'lib/Iceberg_spikes.png';\n\nclass IceBerg extends MovingObject {\n  constructor(options = {}) {\n    super(options)\n    options.pos = options.pos || options.game.randomPosition();\n    options.vel = options.vel || Util.randomVec(DEFAULTS.SPEED);\n    options.color = DEFAULTS.COLOR;\n    options.radius = DEFAULTS.RADIUS;\n    options.x = 200;\n    options.y = 200;\n    options.spriteX = 0;\n    options.spriteY = 35;\n    options.spriteWidth = 90;\n    options.spriteHeight = 70;\n    options.image = icebergImg.src;\n    this.icebergImg = document.getElementById('iceberg');\n    MovingObject.call(this, options);\n  }\n  bounds() {\n    return {\n      left: this.x,\n      right: this.x + DEFAULTS.WIDTH,\n      top: this.y,\n      bottom: this.y + DEFAULTS.HEIGHT,\n    };\n  }\n  drawIceberg(ctx) {\n    ctx.drawImage(this.icebergImg, this.pos[0], this.pos[1], 80, 80);\n  }\n}\n\nmodule.exports = IceBerg;","const Util = require('./util.js');\n\nconst MovingObject = function (options) {\n  this.pos = options.pos;\n  this.vel = options.vel;\n  this.radius = options.radius;\n  this.color = options.color;\n  this.game = options.game;\n};\n\nconst TIME_DELTA = 1000 / 60;\n\nMovingObject.prototype.draw = function (ctx) {\n  ctx.fillStyle = this.color;\n  ctx.beginPath();\n  ctx.arc(this.pos[0], this.pos[1], this.radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n}\n\nMovingObject.prototype.moveIceberg = function (delta) {\n  const vel = delta / TIME_DELTA;\n  const moveX = this.vel[0] * vel * (5 * Math.random());\n\n  if (moveX < this.vel[0]) {\n    this.pos = [this.pos[0] + moveX, this.pos[1]];\n  }\n\n  if (this.game.isOutOfBounds(this.pos)) {\n    this.vel[0] = this.vel[0];\n    this.vel[1] = this.vel[1];\n  };\n};\n\nMovingObject.prototype.moveWave = function (delta) {\n  const vel = delta / TIME_DELTA;\n  const moveX = this.vel[0] * vel;\n\n  if (moveX > this.vel[0]) {\n    this.pos = [this.pos[0] + moveX, this.pos[1]];\n  }\n}\n\nMovingObject.prototype.moveSurfer = function (delta) {\n  const vel = delta / TIME_DELTA;\n  const moveX = this.vel[0] * vel;\n  const moveY = this.vel[1] * vel;\n  \n  this.pos = [this.pos[0] + moveX, this.pos[1] + moveY];\n\n  if (this.game.isOutOfBounds(this.pos)) {\n    this.vel[0] = 0;\n    this.vel[1] = 0;\n  };\n};\n\nMovingObject.prototype.remove = function () {\n  this.game.remove(this);\n}\n\nMovingObject.prototype.crashedWith = function (other) {\n  const centerDist = Util.dist(this.pos, other.pos);\n  return centerDist < (this.radius + other.radius);\n};\n\nmodule.exports = MovingObject;","const MovingObject = require(\"./moving_object.js\");\nconst Util = require(\"./util.js\");\n\nconst DEFAULTS = {\n  COLOR: '#0a5aa1',\n  RADIUS: 15,\n  WAVE_WIDTH: 50,\n  WAVE_HEIGHT: 40,\n  SPEED: 1,\n};\n\nconst waveImg = new Image ();\nwaveImg.src = 'lib/hqdefault.png';\n\nclass Power extends MovingObject {\n  constructor(options = {}) {\n    super(options)\n    options.pos = options.pos || options.game.randomWavePosition();\n    options.vel = options.vel || Util.randomVec(DEFAULTS.SPEED);\n    options.radius = DEFAULTS.RADIUS;\n    options.color = DEFAULTS.COLOR;\n    options.image = waveImg.src;\n    options.waveImg = document.getElementById('power');\n    MovingObject.call(this, options);\n  }\n\n  drawWave(ctx) {\n    ctx.drawImage(waveImg, this.pos[0], this.pos[1], 80, 80);\n  }\n}\n\nmodule.exports = Power;","const MovingObject = require(\"./moving_object.js\");\nconst Power = require('./power.js');\nconst Util = require(\"./util.js\");\n\nconst DEFAULTS = {\n  CHARACTER_WIDTH: 90,\n  CHARACTER_HEIGHT: 100,\n  COLOR: '#50b9d9',\n  RADIUS: 20,\n  SPEED: 1,\n};\n\nconst surferImg = new Image ();\nsurferImg.src = 'lib/main-qimg-9051717fa22925b5af3ee924dc6c5491.png';\n// surferImg.src = 'lib/tumblr_a34e739e74509fc7166ec36de6fd31d9_4aada2e4_1280.png';\n\nconst Surfer = function (options) {\n  options.color = DEFAULTS.COLOR;\n  options.radius = DEFAULTS.RADIUS;\n  options.pos = options.pos || [150,250]\n  options.vel = options.vel || [0,0];\n  options.x = 200;\n  options.y = 200;\n  options.spriteX = 0;\n  options.spriteY = 35;\n  options.spriteWidth = 90;\n  options.spriteHeight = 70;\n  options.image = surferImg.src\n  options.surferImg = document.getElementById('avatar');\n  MovingObject.call(this, options)\n}\n\nUtil.inherits(Surfer, MovingObject);\n\nSurfer.prototype.bounds = function () {\n  return {\n    left: this.x,\n    right: this.x + DEFAULTS.CHARACTER_WIDTH,\n    top: this.y,\n    bottom: this.y - DEFAULTS.CHARACTER_HEIGHT,\n  };\n};\n\nSurfer.prototype.sprite = function (options) {\n  let that = {};\n\n  that.context = options.context;\n  that.width = options.width;\n  that.height = options.height; \n  that.image = options.image;\n\n  return that;\n}\n\nSurfer.prototype.drawSurfer = function (ctx) {\n  ctx.drawImage(surferImg, this.pos[0], this.pos[1], 100, 100)\n}\n\nSurfer.prototype.waterBend = function () {\n  let waveVel = [1, 0];\n  \n  let wave = new Power({\n    pos: this.pos,\n    vel: waveVel,\n    color: this.color,\n    game: this.game,\n  });\n  this.game.waves.push(wave)\n};\n\nSurfer.prototype.surf = function (impulse) {\n  this.vel[0] += impulse[0];\n  this.vel[1] += impulse[1];\n};\n\nmodule.exports = Surfer;","const Util = {\n  dir (vec) {\n    var norm = Util.norm(vec);\n    return Util.scale(vec, 1 / norm);\n  },\n\n  dist (pos1, pos2) {\n    return Math.sqrt(\n      Math.pow(pos1[0] - pos2[0], 2) + Math.pow(pos1[1] - pos2[1], 2)\n    );\n  },\n\n  norm (vec) {\n    return Util.dist([0,0], vec);\n  },\n\n  randomVec (length) {\n    var deg = 2 * Math.PI * Math.random();\n    return Util.scale([-1 * Math.abs(Math.sin(deg)), Math.abs(Math.cos(deg))], length);\n  },\n\n  scale (vec, m) {\n    return [vec[0] * m, vec[1] * m];\n  },\n\n  inherits(ChildClass, BaseClass) {\n    function Surrogate () { this.constructor = ChildClass; }\n    Surrogate.prototype = BaseClass.prototype;\n    ChildClass.prototype = new Surrogate();\n  },\n};\n\nmodule.exports = Util;","  \n//     keymaster.js\n//     (c) 2011-2013 Thomas Fuchs\n//     keymaster.js may be freely distributed under the MIT license.\n\n;(function(global){\n  var k,\n    _handlers = {},\n    _mods = { 16: false, 18: false, 17: false, 91: false },\n    _scope = 'all',\n    // modifier keys\n    _MODIFIERS = {\n      '⇧': 16, shift: 16,\n      '⌥': 18, alt: 18, option: 18,\n      '⌃': 17, ctrl: 17, control: 17,\n      '⌘': 91, command: 91\n    },\n    // special keys\n    _MAP = {\n      backspace: 8, tab: 9, clear: 12,\n      enter: 13, 'return': 13,\n      esc: 27, escape: 27, space: 32,\n      left: 37, up: 38,\n      right: 39, down: 40,\n      del: 46, 'delete': 46,\n      home: 36, end: 35,\n      pageup: 33, pagedown: 34,\n      ',': 188, '.': 190, '/': 191,\n      '`': 192, '-': 189, '=': 187,\n      ';': 186, '\\'': 222,\n      '[': 219, ']': 221, '\\\\': 220\n    },\n    code = function(x){\n      return _MAP[x] || x.toUpperCase().charCodeAt(0);\n    },\n    _downKeys = [];\n\n  for(k=1;k<20;k++) _MAP['f'+k] = 111+k;\n\n  // IE doesn't support Array#indexOf, so have a simple replacement\n  function index(array, item){\n    var i = array.length;\n    while(i--) if(array[i]===item) return i;\n    return -1;\n  }\n\n  // for comparing mods before unassignment\n  function compareArray(a1, a2) {\n    if (a1.length != a2.length) return false;\n    for (var i = 0; i < a1.length; i++) {\n        if (a1[i] !== a2[i]) return false;\n    }\n    return true;\n  }\n\n  var modifierMap = {\n      16:'shiftKey',\n      18:'altKey',\n      17:'ctrlKey',\n      91:'metaKey'\n  };\n  function updateModifierKey(event) {\n      for(k in _mods) _mods[k] = event[modifierMap[k]];\n  };\n\n  // handle keydown event\n  function dispatch(event) {\n    var key, handler, k, i, modifiersMatch, scope;\n    key = event.keyCode;\n\n    if (index(_downKeys, key) == -1) {\n        _downKeys.push(key);\n    }\n\n    // if a modifier key, set the key.<modifierkeyname> property to true and return\n    if(key == 93 || key == 224) key = 91; // right command on webkit, command on Gecko\n    if(key in _mods) {\n      _mods[key] = true;\n      // 'assignKey' from inside this closure is exported to window.key\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = true;\n      return;\n    }\n    updateModifierKey(event);\n\n    // see if we need to ignore the keypress (filter() can can be overridden)\n    // by default ignore key presses if a select, textarea, or input is focused\n    if(!assignKey.filter.call(this, event)) return;\n\n    // abort if no potentially matching shortcuts found\n    if (!(key in _handlers)) return;\n\n    scope = getScope();\n\n    // for each potential shortcut\n    for (i = 0; i < _handlers[key].length; i++) {\n      handler = _handlers[key][i];\n\n      // see if it's in the current scope\n      if(handler.scope == scope || handler.scope == 'all'){\n        // check if modifiers match if any\n        modifiersMatch = handler.mods.length > 0;\n        for(k in _mods)\n          if((!_mods[k] && index(handler.mods, +k) > -1) ||\n            (_mods[k] && index(handler.mods, +k) == -1)) modifiersMatch = false;\n        // call the handler and stop the event if neccessary\n        if((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch){\n          if(handler.method(event, handler)===false){\n            if(event.preventDefault) event.preventDefault();\n              else event.returnValue = false;\n            if(event.stopPropagation) event.stopPropagation();\n            if(event.cancelBubble) event.cancelBubble = true;\n          }\n        }\n      }\n    }\n  };\n\n  // unset modifier keys on keyup\n  function clearModifier(event){\n    var key = event.keyCode, k,\n        i = index(_downKeys, key);\n\n    // remove key from _downKeys\n    if (i >= 0) {\n        _downKeys.splice(i, 1);\n    }\n\n    if(key == 93 || key == 224) key = 91;\n    if(key in _mods) {\n      _mods[key] = false;\n      for(k in _MODIFIERS) if(_MODIFIERS[k] == key) assignKey[k] = false;\n    }\n  };\n\n  function resetModifiers() {\n    for(k in _mods) _mods[k] = false;\n    for(k in _MODIFIERS) assignKey[k] = false;\n  };\n\n  // parse and assign shortcut\n  function assignKey(key, scope, method){\n    var keys, mods;\n    keys = getKeys(key);\n    if (method === undefined) {\n      method = scope;\n      scope = 'all';\n    }\n\n    // for each shortcut\n    for (var i = 0; i < keys.length; i++) {\n      // set modifier keys if any\n      mods = [];\n      key = keys[i].split('+');\n      if (key.length > 1){\n        mods = getMods(key);\n        key = [key[key.length-1]];\n      }\n      // convert to keycode and...\n      key = key[0]\n      key = code(key);\n      // ...store handler\n      if (!(key in _handlers)) _handlers[key] = [];\n      _handlers[key].push({ shortcut: keys[i], scope: scope, method: method, key: keys[i], mods: mods });\n    }\n  };\n\n  // unbind all handlers for given key in current scope\n  function unbindKey(key, scope) {\n    var multipleKeys, keys,\n      mods = [],\n      i, j, obj;\n\n    multipleKeys = getKeys(key);\n\n    for (j = 0; j < multipleKeys.length; j++) {\n      keys = multipleKeys[j].split('+');\n\n      if (keys.length > 1) {\n        mods = getMods(keys);\n      }\n\n      key = keys[keys.length - 1];\n      key = code(key);\n\n      if (scope === undefined) {\n        scope = getScope();\n      }\n      if (!_handlers[key]) {\n        return;\n      }\n      for (i = 0; i < _handlers[key].length; i++) {\n        obj = _handlers[key][i];\n        // only clear handlers if correct scope and mods match\n        if (obj.scope === scope && compareArray(obj.mods, mods)) {\n          _handlers[key][i] = {};\n        }\n      }\n    }\n  };\n\n  // Returns true if the key with code 'keyCode' is currently down\n  // Converts strings into key codes.\n  function isPressed(keyCode) {\n      if (typeof(keyCode)=='string') {\n        keyCode = code(keyCode);\n      }\n      return index(_downKeys, keyCode) != -1;\n  }\n\n  function getPressedKeyCodes() {\n      return _downKeys.slice(0);\n  }\n\n  function filter(event){\n    var tagName = (event.target || event.srcElement).tagName;\n    // ignore keypressed in any elements that support keyboard data input\n    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');\n  }\n\n  // initialize key.<modifier> to false\n  for(k in _MODIFIERS) assignKey[k] = false;\n\n  // set current scope (default 'all')\n  function setScope(scope){ _scope = scope || 'all' };\n  function getScope(){ return _scope || 'all' };\n\n  // delete all handlers for a given scope\n  function deleteScope(scope){\n    var key, handlers, i;\n\n    for (key in _handlers) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length; ) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);\n        else i++;\n      }\n    }\n  };\n\n  // abstract key logic for assign and unassign\n  function getKeys(key) {\n    var keys;\n    key = key.replace(/\\s/g, '');\n    keys = key.split(',');\n    if ((keys[keys.length - 1]) == '') {\n      keys[keys.length - 2] += ',';\n    }\n    return keys;\n  }\n\n  // abstract mods logic for assign and unassign\n  function getMods(key) {\n    var mods = key.slice(0, key.length - 1);\n    for (var mi = 0; mi < mods.length; mi++)\n    mods[mi] = _MODIFIERS[mods[mi]];\n    return mods;\n  }\n\n  // cross-browser events\n  function addEvent(object, event, method) {\n    if (object.addEventListener)\n      object.addEventListener(event, method, false);\n    else if(object.attachEvent)\n      object.attachEvent('on'+event, function(){ method(window.event) });\n  };\n\n  // set the handlers globally on document\n  addEvent(document, 'keydown', function(event) { dispatch(event) }); // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48\n  addEvent(document, 'keyup', clearModifier);\n\n  // reset modifiers to false whenever the window is (re)focused.\n  addEvent(window, 'focus', resetModifiers);\n\n  // store previously defined key\n  var previousKey = global.key;\n\n  // restore previously defined key and return reference to our key object\n  function noConflict() {\n    var k = global.key;\n    global.key = previousKey;\n    return k;\n  }\n\n  // set window.key and window.key.set/get/deleteScope, and the default filter\n  global.key = assignKey;\n  global.key.setScope = setScope;\n  global.key.getScope = getScope;\n  global.key.deleteScope = deleteScope;\n  global.key.filter = filter;\n  global.key.isPressed = isPressed;\n  global.key.getPressedKeyCodes = getPressedKeyCodes;\n  global.key.noConflict = noConflict;\n  global.key.unbind = unbindKey;\n\n  if(typeof module !== 'undefined') module.exports = assignKey;\n\n})(this);","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","document.addEventListener('DOMContentLoaded', () => {\n  const GameView = require('./game_view.js');\n  const Game = require('./game.js');\n  \n  const canvas = document.getElementById(\"game-canvas\")\n  const ctx = canvas ? canvas.getContext(\"2d\") : {};\n  \n  if (canvas) {\n    canvas.setAttribute(\"width\", \"1200px\")\n    canvas.setAttribute(\"height\", \"550px\")\n  }\n  \n  const startButton = document.getElementById('start');\n  const restartButton = document.getElementById('restart');\n  const splash = document.getElementById('splash');\n  const endScreen = document.getElementById(\"end-screen\");\n  const g = new Game(ctx);\n  const game = new GameView(g, ctx)\n  const gameContainer = document.getElementById(\"game-container\");\n  \n  if (startButton) {\n    startButton.addEventListener(\"click\", () => {\n      splash.classList.add(\"hidden\");\n      gameContainer.classList.remove(\"hidden\");\n      canvas.classList.remove(\"hidden\");\n      game.start();\n    });\n  }\n  \n  if (restartButton) {\n    restartButton.addEventListener(\"click\", () => {\n      window.location.reload()\n      endScreen.classList.add(\"hidden\");\n      gameContainer.classList.remove(\"hidden\");\n      game.restart();\n    });\n  }\n})"],"names":[],"sourceRoot":""}